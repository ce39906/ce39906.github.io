<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Leveldb skiplist 实现以及解析 | Ce39906&#39;s Blog</title>

<link rel="shortcut icon" href="https://ce39906.github.io//favicon.ico?v=1611803024881">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://ce39906.github.io//styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-188349426-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-188349426-1');
</script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Ce39906&#39;s Blog
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1611803024881"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Leveldb skiplist 实现以及解析
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2018-04-27 ·
                    </time>
                    
                        <a href="https://ce39906.github.io//tag/sKN_FIXf8-e" class="post-tags">
                            # Leveldb
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>RT</p>
<!-- more -->
<h2 id="skiplist-原理介绍">skiplist 原理介绍</h2>
<p>skiplist 由William Pugh 在论文<a href="http://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf">Skip Lists: A Probabilistic Alternative to Balanced Trees</a> 中提出的一种数据结构，skiplist 是一种随机化存储的多层线性链表结构，插入，查找，删除的都是对数级别的时间复杂度。skiplist 和平衡树有相同的时间复杂度，但相比平衡树，skip实现起来更简单。</p>
<p>下图是wikipedia 上一个一个高度为4的skiplist</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/86/Skip_list.svg" alt="avatar"><br>
从垂直角度看，skiplist 的第0层以单链表的形式按照从小到大的顺序存储全部数据，越高层的链表的节点数越少，这样的特点实现了skiplist 在定位某个位置时，通过在高层较少的节点中查找就可以确定需要定位的位置处于哪个区间，从高层到低层不断缩小查找区间。以上图为例，比如我们需要在skiplist中查找2，查找过程如下，首先在最高层确定到2只可能处于1-&gt;NULL 这个区间，然后在第三层查找确定 2 只可能处于 1-&gt;4 这个区间，继续在第二层查找确定2 只可能处于1-3 这区间，最后在最底层1-&gt;3 这个区间查找可以确定2 是否存在于skiplist之中。<br>
下图是wikipedia上提供的表示skiplist插入过程的一张gif,此图形象的说明了skiplist 定位以及插入节点的过程。<br>
<img src="https://myblog-1256683296.cos.ap-beijing.myqcloud.com/Skip_list_add_element-en.gif" alt="skiplist insert"><br>
从水平角度来看，skiplist实现在链表开始的时候设置名为head 的哨兵节点，每一层链表的结束为止全部指向NULL。</p>
<h2 id="leveldb-实现">leveldb 实现</h2>
<p>leveldb 实现的skiplist位于db/skiplist.h。</p>
<h3 id="skiplist-node-类型定义">skiplist Node 类型定义</h3>
<pre><code>// Implementation details follow
template&lt;typename Key, class Comparator&gt;
struct SkipList&lt;Key,Comparator&gt;::Node {
  explicit Node(const Key&amp; k) : key(k) { }
  // Node 存储的内容
  Key const key;

  // Accessors/mutators for links.  Wrapped in methods so we can
  // add the appropriate barriers as necessary.
  // 获取当前节点在指定level的下一个节点
  Node* Next(int n) {
    assert(n &gt;= 0);
    // Use an 'acquire load' so that we observe a fully initialized
    // version of the returned Node.
    return reinterpret_cast&lt;Node*&gt;(next_[n].Acquire_Load());
  }
  // 将当前节点在指定level的下一个节点设置为x
  void SetNext(int n, Node* x) {
    assert(n &gt;= 0);
    // Use a 'release store' so that anybody who reads through this
    // pointer observes a fully initialized version of the inserted node.
    next_[n].Release_Store(x);
  }
  // 无内存屏障版本set。关于leveldb 内存屏障在新一篇博客介绍
  // No-barrier variants that can be safely used in a few locations.
  Node* NoBarrier_Next(int n) {
    assert(n &gt;= 0);
    return reinterpret_cast&lt;Node*&gt;(next_[n].NoBarrier_Load());
  }
  void NoBarrier_SetNext(int n, Node* x) {
    assert(n &gt;= 0);
    next_[n].NoBarrier_Store(x);
  }

 private:
  // Array of length equal to the node height.  next_[0] is lowest level link.
  // 当前节点的下一个节点数组
  port::AtomicPointer next_[1];
};

</code></pre>
<h3 id="skiplist-类成员变量">skiplist 类成员变量</h3>
<pre><code>private:
  // 使用枚举类型定义skiplist 最高高度
  enum { kMaxHeight = 12 };

  // Immutable after construction
  // 用户定制的比较器
  Comparator const compare_;
  // leveldb 实现的简单的内存分配器
  Arena* const arena_;    // Arena used for allocations of nodes
  // skiplist 的前置哨兵节点
  Node* const head_;

  // Modified only by Insert().  Read racily by readers, but stale
  // values are ok.
  // 记录当前skiplist使用的最高高度
  port::AtomicPointer max_height_;   // Height of the entire list
</code></pre>
<h3 id="skiplist-插入">skiplist 插入</h3>
<pre><code>template&lt;typename Key, class Comparator&gt;
void SkipList&lt;Key,Comparator&gt;::Insert(const Key&amp; key) {
  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()
  // here since Insert() is externally synchronized.
  // 声明prev节点，代表插入位置的前一个节点
  Node* prev[kMaxHeight];
  // 使用FindGreaterOrEqual函数找到第一个大于等于插入key的位置
  Node* x = FindGreaterOrEqual(key, prev);

  // Our data structure does not allow duplicate insertion
  assert(x == NULL || !Equal(key, x-&gt;key));
  // 使用随机数获取该节点的插入高度
  int height = RandomHeight();
  if (height &gt; GetMaxHeight()) {
    // 大于当前skiplist 最高高度的话，将多出的来的高度的prev 设置为哨兵节点
    for (int i = GetMaxHeight(); i &lt; height; i++) {
      prev[i] = head_;
    }
    //fprintf(stderr, &quot;Change height from %d to %d\n&quot;, max_height_, height);

    // It is ok to mutate max_height_ without any synchronization
    // with concurrent readers.  A concurrent reader that observes
    // the new value of max_height_ will see either the old value of
    // new level pointers from head_ (NULL), or a new value set in
    // the loop below.  In the former case the reader will
    // immediately drop to the next level since NULL sorts after all
    // keys.  In the latter case the reader will use the new node.
// 跟新max_height_    max_height_.NoBarrier_Store(reinterpret_cast&lt;void*&gt;(height));
  }
  // 创建要插入的节点对象
  x = NewNode(key, height);
  for (int i = 0; i &lt; height; i++) {
    // NoBarrier_SetNext() suffices since we will add a barrier when
    // we publish a pointer to &quot;x&quot; in prev[i].
    // 首先将x的next 指向prev 的下一个节点
    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));
    // 将prev 指向x
    prev[i]-&gt;SetNext(i, x);
  }
}
</code></pre>
<h3 id="skiplist-查找">skiplist 查找</h3>
<pre><code>template&lt;typename Key, class Comparator&gt;
bool SkipList&lt;Key,Comparator&gt;::Contains(const Key&amp; key) const {
  // 找到大于等于当前key的第一个node,然后判断node 的key
  // 和传入的key 是否相等
  Node* x = FindGreaterOrEqual(key, NULL);
  if (x != NULL &amp;&amp; Equal(key, x-&gt;key)) {
    return true;
  } else {
    return false;
  }
}
</code></pre>
<h3 id="findgreaterorequal">FindGreaterOrEqual</h3>
<p>函数的作用是找到第一个大于或等于指定的key 的node,以及该node的前一个node</p>
<pre><code>template&lt;typename Key, class Comparator&gt;
typename SkipList&lt;Key,Comparator&gt;::Node* SkipList&lt;Key,Comparator&gt;::FindGreaterOrEqual(const Key&amp; key, Node** prev)
    const {
  Node* x = head_;
  // level 从0 开始编码
  int level = GetMaxHeight() - 1;
  while (true) {
	// 定位到当前level的下一个节点
    Node* next = x-&gt;Next(level);
    // key 没有在当前区间
    if (KeyIsAfterNode(key, next)) {
      // Keep searching in this list
      x = next;
    } else {
	  // key 在当前区间，在低level 继续查找，
	  // 在查找的同时设置prev 节点
      if (prev != NULL) prev[level] = x;
      // 在最低level找到相应位置
      if (level == 0) {
        return next;
      } else {
        // Switch to next list
        level--;
      }
    }
  }
}
</code></pre>
<h3 id="randomheight">RandomHeight</h3>
<p>利用随机数实现每次有4分之一的概率增长高度。</p>
<pre><code>template&lt;typename Key, class Comparator&gt;
int SkipList&lt;Key,Comparator&gt;::RandomHeight() {
  // Increase height with probability 1 in kBranching
  static const unsigned int kBranching = 4;
  int height = 1;
  while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) {
    height++;
  }
  assert(height &gt; 0);
  assert(height &lt;= kMaxHeight);
  return height;
}
</code></pre>
<h3 id="findlessthan">FindLessThan</h3>
<pre><code>template&lt;typename Key, class Comparator&gt;
typename SkipList&lt;Key,Comparator&gt;::Node*
SkipList&lt;Key,Comparator&gt;::FindLessThan(const Key&amp; key) const {
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    assert(x == head_ || compare_(x-&gt;key, key) &lt; 0);
    \// 在当前level 查找
    Node* next = x-&gt;Next(level);
    //  if 分支为true 的时候表示需要查找的位置在当前区间
    if (next == NULL || compare_(next-&gt;key, key) &gt;= 0) {
      // 在最后一层停止查找
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      // 在当前level 就找到了比key 小的节点
      x = next;
    }
  }
}
</code></pre>
<h2 id="总结">总结</h2>
<p>skiplist最底层单链表有序存储全部元素，利用多层有序链表的结构实现加速索引的功能，处于越高level 节点的链表越稀疏查找速度越快，在不断向下查找的过程中不断缩小查找空间。<br>
总的来说，skiplist 是一种设计巧妙的数据结构，相比红黑树实现简单，插入查找删除的时间复杂度和红黑树一致，但是顺序遍历的时间复杂度优于红黑树。leveldb 的实现可读性高，容易理解。</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://ce39906.github.io//post/C-拼接长字符串" class="post-title gt-a-link">
                    C++ 拼接长字符串
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">算法及读书杂记</div>
    <div class="social-container">
        
            
                <a href="https://github.com/ce39906" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        
    </div>
    <div>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
